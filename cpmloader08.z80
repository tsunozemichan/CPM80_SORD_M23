
;
; FDC I/O ports
;
FDC_COMMAND_REG EQU 0C0H
FDC_STATUS_REG 	EQU FDC_COMMAND_REG
FDC_TRACK_REG 	EQU 0C1H
FDC_SECTOR_REG 	EQU 0C2H
FDC_DATA_REG 	EQU 0C3H
DMA_ADDRESS 	EQU 0C4H
FDC_CONTROL_REG EQU 0C5H
DMA_BANK_SEL 	EQU 0C6H

DMA_TRANS_ADDRESS EQU 0A5DH


READBUF EQU 01500H
RESULT  EQU 01400H

DEST_ADDRESS EQU 0800H

;
; CRTC
;
VRAM_TXT_TOP EQU 0F800H
VRAM_ATR_TOP EQU 0F000H
CRTC_ADD EQU 0F0H
CRTC_VAL EQU 0F1H

;;; Constants
CR:		EQU	0x0D
LF:		EQU	0x0A
BS:		EQU	0x08
DEL:	EQU	0x7F

;
;
;

	ORG 0H
	DI
START:
	LD HL,01000H
	LD SP,HL ; stack pointer
	LD HL,DEST_ADDRESS ; destination address
	EX DE,HL
	LD HL,20H ; source address
	LD BC,800H ; 800H is 2kB
	LDIR
	JP MAIN:

	ORG DEST_ADDRESS
MAIN:
	;
	; 0 MEMORY FILL FROM 0 TO 100H
	;
	LD HL,0H
	LD BC,100H
	LD A,0H
	CALL MEMORY_FILL

	CALL CRT_INIT

	; DMA Bank Select
	XOR A ; A=0
	OUT (DMA_BANK_SEL), A

	; FDC_CONTROL_REG
	LD A, 012H
	OUT (FDC_CONTROL_REG), A
	LD B,30H
SELF_LOOP: DJNZ SELF_LOOP

LOOP_1:
	IN A, (FDC_STATUS_REG)
	BIT 0,A
	JR NZ, LOOP_1


	; FDC init

	; FDC_CONTROL_REG
	LD A, 051H
	OUT (FDC_CONTROL_REG), A
	LD B,30H
SELF_LOOP2: DJNZ SELF_LOOP2

;	LD A,01H
;	LD (FDC_CONTROL_REG),A

	IN A,(FDC_DATA_REG)
	XOR 0FFH
	OUT (FDC_DATA_REG),A
	LD B,A
	EX (SP),HL
	EX (SP),HL
	IN A,(FDC_DATA_REG)
	CP B ; IF NOT EQUAL
	JP NZ,ABORT ; GO ABORT
	LD A,0D0H ; FORCE INT
	CALL FDCOUT
	LD B,30H
MLOOP1:	DJNZ MLOOP1
;
	PUSH AF
	LD A,"S"
	CALL PUTCHAR
	POP AF

	CALL RESTORE
;
	PUSH AF
	LD A,"R"
	CALL PUTCHAR
	POP AF
;
; 1st SEEK
;
	LD E,22  ; TARGET TRACK No.22, at CP/M SYS
;
DO_SEEK0:
	CALL SEEK
	PUSH AF
	LD A, "."
	CALL PUTCHAR
	POP AF
	JR Z,GO_DMA0 ; ノーエラーならDMA付きREADを開始する
	JR DO_SEEK0 ; seekに成功するまで繰り返す
GO_DMA0:
;
	PUSH AF
	LD A, "*"
	CALL PUTCHAR
	LD A,30H
WAIT_LOOP1:
	DEC A
	JR NZ,WAIT_LOOP1
	POP AF

	; DMA Bank Select
	PUSH AF
	XOR A ; A=0
	OUT (DMA_BANK_SEL), A
	POP AF
;
	LD B,08 ; LOOP COUNT is 8 sectors
	LD C,09 ; INITIAL SECTOR NO. is 9 to 16 sector reading
;
READ_LOOP0:
	CALL GO_DMA_AND_READ0
	INC C
	LD A,(DMA_TRANS_ADDRESS) ; memory address of DMA transfer address
	INC A ; 256 byte incriment
	LD (DMA_TRANS_ADDRESS),A
	DJNZ READ_LOOP0

	PUSH AF
	LD A,"1"
	CALL PUTCHAR
	POP AF
;
; 2nd SEEK
;
	LD E,23  ; TARGET TRACK No.23, at CP/M SYS
;
DO_SEEK1:
	CALL SEEK
	PUSH AF
	LD A, "."
	CALL PUTCHAR
	POP AF
	JR Z,GO_DMA1
	JR DO_SEEK1
GO_DMA1:
	LD B,016 ; LOOP COUNT is 16 sectors
	LD C,01 ; INITIAL SECTOR NO. is 1 to 16 sector reading
;
READ_LOOP1:
	CALL GO_DMA_AND_READ0
	INC C
	LD A,(DMA_TRANS_ADDRESS) ; memory address of DMA transfer address
	INC A ; 256 byte incriment
	LD (DMA_TRANS_ADDRESS),A
	DJNZ READ_LOOP1
;
; 3nd SEEK
;
	LD E,24  ; TARGET TRACK No.24, at CP/M SYS
;
DO_SEEK2:
	CALL SEEK
	JR Z,GO_DMA2
	JR DO_SEEK2
GO_DMA2:
	LD B,08 ; LOOP COUNT is 8 sectors
	LD C,01 ; INITIAL SECTOR NO. is 1 to 8 sector reading
;
READ_LOOP2:
	CALL GO_DMA_AND_READ0
	INC C
	LD A,(DMA_TRANS_ADDRESS) ; memory address of DMA transfer address
	INC A ; 256 byte incriment
	LD (DMA_TRANS_ADDRESS),A
	DJNZ READ_LOOP2

	JP 0E200H ; Jump E200H @ 58k memory model. 
;	HALT
;
;
; ----------------------------------------------------------------
;
;
; FDC COMMAND OUT subroutine
;
FDCOUT:
	OUT (FDC_COMMAND_REG),A
	LD A,30H
WLOOP: DEC A
	JR NZ,WLOOP
LOOP2:
	IN A,(FDC_STATUS_REG)
	BIT 0H,A ; BUSY IS CLEAR?
	JR NZ,LOOP2
	RET

;
; RESTORE subroutine
;
RESTORE:
RESTORE_LOOP:
	LD A,0BH ; restore command. 15ms, Head load, Verify OFF
	CALL FDCOUT
	BIT 7,A ; Not Ready?
	JR NZ,RESTORE_LOOP
	AND 98H
	JR NZ,RESTORE
	RET
;
;
; SEEK subroutine
; E is Track No.
;
SEEK:
	LD A,E ; E is Track No.
	OUT (FDC_DATA_REG),A
	LD A,1BH ; SEEK COMMAND. 15ms, Head Load, Verify OFF
	CALL FDCOUT
	AND 98H
	RET
;
; DMA setting & Go
; HL is Address of DMA Command chain
;		but top value is No of DMA Command chain
DMA_ON:
	PUSH HL
	PUSH BC
	LD B,(HL)
	INC HL
	LD C,DMA_ADDRESS
	OTIR
	POP BC
	POP HL
	RET
;
; DMA setting & FDD read FOR SIDE 0
; C is Sector No.
;
GO_DMA_AND_READ0:
	PUSH BC
	LD B,05H
	LD A,C
	OUT (FDC_SECTOR_REG),A
READ0_RETRY:

	PUSH AF
	LD A, "+"
	CALL PUTCHAR
	POP AF

	LD HL,DMA_COMMANDS
	CALL DMA_ON
;	AND 20H
	LD A,80H ; READ DATA COMMAND for Side 0
DO_FDC0:
	CALL FDCOUT

	PUSH AF
	LD A, "-"
	CALL PUTCHAR
	POP AF

	PUSH AF
	LD A,083H ; DMA STOP
	OUT (DMA_ADDRESS),A
	POP AF
;	AND 0FCH
	AND 03CH
	JR Z, READ0_SUCCESS
	DEC B
	JR NZ, READ0_RETRY
	JR ABORT
READ0_SUCCESS:
	POP BC
	RET


;
; ABORT
;
ABORT:
;	LD A,"A"
;	CALL CONOUT
	LD A,"H"
	CALL PUTCHAR
	HALT
;
; MEMORY FILL
;
MEMORY_FILL:
	LD (HL),A
	LD D,H
	LD E,L
	INC DE
	DEC BC
	LD A,B
	OR C
	RET Z
	LDIR
	RET



CRT_INIT:

	LD HL,0F000H
	LD BC,0800H

	LD B,050H
	LD DE,0FFFFH
	LD A,20H
CLEAR_ALL_LINE:
	OUT (0D2H),A
	LD (HL),A
	INC HL
	SBC HL,DE
	JR NZ,CLEAR_ALL_LINE

	LD DE, VRAM_TXT_TOP ; 最初の文字列表示位置(左上隅)
	LD (CURSOR_LOCATE),DE
	LD (TOP_VIEW),DE
	LD DE, 0FFD0H
	LD (NEED_DO_SCROLL_POINT),DE

	RET


;
; CRTC Put Character
;

;
; １文字表示サブルーチン
; A regにアスキーコードが入っている。
;
PUTCHAR:
	AND A
	JR Z, PUTCHAR_RET
	LD DE,(CURSOR_LOCATE)
	CP CR
	JP Z, DO_CR_2 ; CRの処理
	CP LF
	JP Z, DO_LF ; LFの処理
	CP BS
	JP Z, DO_BS ; BSの処理
DO_NORMAL:
	OUT (0D2H),A ; access to RAM page 1
	LD (DE),A ; put character
;
; 境界を超えたかの判定。FFFFHの次はF800Hになる
;
	PUSH AF
	LD A,D
	CP 0FFH
	JR NZ,CURSOR_BOUNDARY_END
	LD A,E
	CP 0FFH
	JR NZ,CURSOR_BOUNDARY_END
	LD DE, VRAM_TXT_TOP-1 ; 現在のカーソル位置 = F800H - 1 
CURSOR_BOUNDARY_END:
	POP AF
	INC DE
DO_BS_RETURN: ; CR,LF,BSの処理で戻ってくる

	LD (CURSOR_LOCATE),DE ; 現在のカーソル位置を更新。
PUTCHAR_RET:
	RET


DO_CR_2:
	PUSH HL
	PUSH BC
	XOR A ; A=0にする
	LD (CR_NOW_CURSOL_LOCATE),DE ; 現在のカーソル位置保存
	LD HL,(TOP_VIEW) ; 左上端をロード
	EX DE,HL
	SBC HL,DE ; 左上端アドレス - 現在のカーソル位置
	JR NC,CONTINUE_CR_2 ; オーバーフローしていないなら通常処理
;
;   TOP_VIEWがCR_NOW_CURSOL_LOCATEよりも大きいとき。
;	つまり、スクロール後の処理
;
	LD HL,(TOP_VIEW)
	LD DE,(CR_NOW_CURSOL_LOCATE) ; CRコードが入った時のカーソル位置
	LD BC,50H ; 画面の桁数(80d)
	LD (CR_BASE_ADDRESS),HL ; 初期値は左上端アドレス
CR_2_SCAN_0:
	LD HL,(CR_BASE_ADDRESS)
	LD (CR_BASE_ADDRESS_PRE),HL
	ADD HL,BC ; 50Hづつ足していく
	LD (CR_BASE_ADDRESS),HL
	JP NC,CR_2_SCAN_0 	; 越境をチェックしている。
						; オーバーフローまでループする。
	LD HL,(CR_BASE_ADDRESS_PRE) ; ループを抜けたときHLはオーバーフロー後の値になっている。
								; 足し算前の値に戻す
	; FFFFHを超えた値がいくつかを調べる。
	; FFFFHまでの値と合わせて、それが1行の桁数50Hを
	; 超えたならCR後の現在カーソル位置は
	; その新しい行の先頭アドレスにならなくてはならない。
	; 
	LD DE,0FFFFH ; 境界値
	EX DE,HL
	SBC HL,DE ; FFFFH - CR_BASE_ADDRESS_PRE = A
			  ; オーバーフローする一つ前の値でFFFFHを引く
	LD DE,50H
	EX DE,HL
	SBC HL,DE ; 50H - A = X ; Xは境界を越えた数
	LD DE,0F800H
	ADD HL,DE ; F800H + X ; この値が境界を含む行の右端のアドレス
	DEC HL ; -2する
	DEC HL
	LD (CR_NEW_ORIGIN),HL ; 新しいCR評価位置になる
	LD (CR_BASE_ADDRESS),HL
	LD DE,(CR_NOW_CURSOL_LOCATE) ; CR命令を受けた時のカーソル位置

	;
	; 現在カーソル位置がF819Hで新しいCR評価位置がF820Hのときに、CR_2_NEW_SCAN_0のループを通ると
	; +50Hされてしまうので、バイパスする処理。
	SBC HL,DE
	JP P,CR_2_BOUNDARY_RETURN
	LD HL,(CR_NEW_ORIGIN)

	LD BC,50H
CR_2_NEW_SCAN_0:
	LD HL,(CR_BASE_ADDRESS)
	LD (CR_BASE_ADDRESS_PRE),HL ; HL=CR_NEW_ORIGIN
	ADD HL,BC ; CR_NEW_ORIGIN + 50H +...
	LD (CR_BASE_ADDRESS),HL
	SBC HL,DE ; (CR_NEW_ORIGIN + 50H +...) > CR_NOW_CURSOL_LOCATE ?
	JP M, CR_2_NEW_SCAN_0 ; DEの方が大きければループ
	LD HL,(CR_BASE_ADDRESS_PRE) ; HL>DE。50Hを足す一つ前の値をHLに入れる。
	LD (CR_BASE_ADDRESS),HL
	LD DE,(CR_BASE_ADDRESS) ; CR後のアドレスをDEに入れる。
	JR CR_2_END
;
;	TOP_VIEWがCR_NOW_CURSOL_LOCATEよりも小さいとき
;
CONTINUE_CR_2:
	LD HL,(TOP_VIEW)
	LD DE,(CR_NOW_CURSOL_LOCATE)
	LD BC,50H
	LD (CR_BASE_ADDRESS),HL
CR_2_SCAN_1:
	LD HL,(CR_BASE_ADDRESS)
	LD (CR_BASE_ADDRESS_PRE),HL
	ADD HL,BC
	LD (CR_BASE_ADDRESS),HL
	SBC HL,DE	; HLが現在のカーソル位置を超えるかチェック
	JP M,CR_2_SCAN_1
	LD HL,(CR_BASE_ADDRESS_PRE)
	LD (CR_BASE_ADDRESS),HL
	LD DE,(CR_BASE_ADDRESS)
CR_2_END:
	POP BC
	POP HL
	JP DO_BS_RETURN

CR_2_BOUNDARY_RETURN:
	LD DE,(CR_BASE_ADDRESS_PRE)
	JR CR_2_END
;
; LINE_FEED 処理
;
DO_LF:
	JP DO_BS_RETURN
;
; BACK SPACE 処理
;
DO_BS:
	JP DO_BS_RETURN ; BSの為の復帰点に戻る。
;
; スクロール 処理
;
DO_SCROLL:
	RET
;
; キースキャン サブルーチン
;
KEY_SCAN_LAP:
	RET

;;;
;;; Other support routines
;;;

STROUT:
	LD	A,(HL)
	AND	A
	RET	Z
	CALL PUTCHAR
	INC	HL
	JR	STROUT

CRLF:
	LD	A,CR
	CALL	PUTCHAR
	LD	A,LF
	JP	 	PUTCHAR
	RET

;
; DMA command chain Parameters
;
	ORG DEST_ADDRESS + 250H
; DMA COMMAND CHAIN
;
DMA_COMMANDS:
	DB 10H,0C3H
	DB 0BBH,01H,0BFH
	DB 06DH
	DB 0C3H,0FFH,00H,02CH,010H,08DH
	DB 00H,0CCH ; CC00H is 58K MEMORY MODEL
;	DB 00H,00H ; 0000H is bootloader test
	DB 8AH
	DB 0CFH,87H

RESTORE_COUNT DB 0FFH
READ_COUNT DB 0AH
SEEK_COUNT DB 0AH

;;;
;;; RAM area
;;;

	;;
	;; Work Area
	;;
	
;	ORG	WORK_B

CURSOR_LOCATE:
	DWFIL 01H

TOP_VIEW:
	DWFIL 01H

NEED_DO_SCROLL_POINT:
	DWFIL 01H

CR_BASE_ADDRESS:
	DWFIL 01H

CR_BASE_ADDRESS_PRE:
	DWFIL 01H

CR_NOW_CURSOL_LOCATE:
	DWFIL 01H

CR_NEW_ORIGIN:
	DWFIL 01H

END
